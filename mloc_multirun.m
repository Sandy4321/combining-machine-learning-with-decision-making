%This is the refactored version of the previous MLTRP codebase.
%This is the main script to perform the experiemts in the corresponding
%paper.

clc; clear all; close all;
s = RandStream('mcg16807','Seed',0); RandStream.setGlobalStream(s); 

% Parameters
n_sample_size_pcts    = [1]; %[.1:.1:1];
n_multirun            = 5; %loop through n_multirun autogenerated decisions if ~=1 else do single exp.
decision_nodes        = 7; %number of nodes in the decision problem.
param0.cost_model_type = 1; % 1 and 2 vary the way predictions are used in wTRP objective.
param0.C2_coeff_range  = [0.01 0.025 0.05 0.075];%l2 regularization coefficient range, default reg param may be bad. see cvalidated.m
param0.n_folds         = 2;
param0.n_repeats       = 1;
param0.C0              = 1000;
param0.fminsearch_opts = optimset('display','off','TolFun',1e-4,...
                                'MaxIter', 500,'MaxFunEvals',1000,...
                                'TolX',1e-4); 
param0.am_maximum_iterations = 25;
param0.am_tolerance    = 10^-4;
if (param0.cost_model_type==1)
    param0.C1array = 0.001*[.5 1 3 5];  %for 7 node data for cost type 1.
else
    param0.C1array = 0.001*[.1 .5 1 5]; %for 7 node data and cost type 2.
end


for j=1:length(n_sample_size_pcts)
    % Load prediction data
    param1 = get_data_given_sample_size(param0,n_sample_size_pcts(j));
    
    for k = 1:n_multirun
        
        % The follwing ensures we don't resample training when new decision
        % data is generated.
        clear param;
        param = param1;
        
        % Load decision data
        [param.C,param.unLabeled] = ...
            get_decision_data(decision_nodes,n_multirun,param);

        % Sequential Process
        sequential{j,k} = sequential_process(param);
        if(sequential{j,k}.feasible~=0)
            
            %only run if forecasts are provided in sequential{j}
            %naive = naive_process(sequential{j,k}.forecasted,param.C);

            %%Simultaneous Process
            param.C2 = param.C0*sequential{j,k}.regularized_coeff;%the best one chosen from sequential
            am_data{j,k} = simultaneous_exhausive(param,'AM');% Alternating Minimization (default)
            %%nm_data{j,k} = simultaneous_exhausive(param,'NM');% NM+MILP if needed
        end

        param_sample_size{j,k} = param;
    end

end

%Prune empty instances: tbd

%% Best test performance in terms of AUC
for j=1:length(n_sample_size_pcts)
    for k = 1:n_multirun

        fprintf('seqnt: %2d,%2d: train auc: %.3f test  auc: %.3f. ',j,k,sequential{j,k}.train_auc,sequential{j,k}.test_auc);
        temp_am1 = 0;
        temp_am2 = 0;
        for i=1:length(am_data{j,k})
    %         fprintf('simul: %d: train auc: %.3f test  auc: %.3f\n',i,am_data{j}{i}.train_auc,am_data{j}{i}.test_auc);
            temp_am1 = max(temp_am1,am_data{j,k}{i}.train_auc);
            temp_am2 = max(temp_am2,am_data{j,k}{i}.test_auc);
        end
        fprintf('simul: %2d,%2d: train auc: %.3f test  auc: %.3f\n',j,k,temp_am1,temp_am2);
    end
end
%% Routes
for j=1:length(n_sample_size_pcts)
    for k = 1:n_multirun
        fprintf('sequn: %d,%d,0: route: %s\n',j,k,num2str(sequential{j,k}.route));
        for i=1:length(am_data{j})
            fprintf('simul: %d,%d,%d: route: %s\n',j,k,i,num2str(am_data{j,k}{i}.route));
        end
    end
end
%% Forecasted probabilities
for j=1:length(n_sample_size_pcts)
    for k = 1:n_multirun

        fprintf('seqnt forecast %d,%d,0: %s \n',j,k,num2str(sequential{j,k}.forecasted));
        for i=1:length(am_data{j,k})
            fprintf('simul forecast %d,%d,%d: %s\n',j,k,i,num2str(am_data{j,k}{i}.forecasted));
        end
    end
end
