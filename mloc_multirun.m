%This is the refactored version of the previous MLTRP codebase.
%This is the main script to perform the experiemts in the corresponding
%paper.

clc; clear all; close all;
s = RandStream('mcg16807','Seed',0); RandStream.setGlobalStream(s); 

% Parameters
result_path            = '/Users/theja/Downloads/temp/mloc_results_feb_2014/';
n_sample_size_pcts     = [.1:.1:1];
n_multirun             = 100; %loop through n_multirun autogenerated decisions if ~=1 else do single exp.
decision_nodes         = 7; %number of nodes in the decision problem.
param0.cost_model_type = 2; % 1 and 2 vary the way predictions are used in wTRP objective.
param0.C2_coeff_range  = [0.01 0.025 0.05 0.075];%l2 regularization coefficient range, default reg param may be bad. see cvalidated.m
param0.n_folds         = 5;
param0.n_repeats       = 3;
param0.C0              = 1000;
param0.fminsearch_opts = optimset('display','off','TolFun',1e-4,...
                                'MaxIter', 500,'MaxFunEvals',1000,...
                                'TolX',1e-4); 
param0.am_maximum_iterations = 25;
param0.am_tolerance    = 10^-4;
if (param0.cost_model_type==1)
    param0.C1array = 0.001*[.5 1 3 5];  %for 7 node data for cost type 1.
else
    param0.C1array = 0.001*[.1 .5 1 5]; %for 7 node data and cost type 2.
end

n_bad_instances = 0;
for j=1:length(n_sample_size_pcts)
    % Load prediction data
    param1 = get_data_given_sample_size(param0,n_sample_size_pcts(j));
    
    k = 0;
    while( k < n_multirun)
        %increment k
        k = k +1;
        
        % The follwing ensures we don't resample training when new decision
        % data is generated.
        clear param;
        param = param1;
        
        % Load decision data
        [param.C,param.unLabeled] = ...
            get_decision_data(decision_nodes,n_multirun,param);

        % Sequential Process
        sequential{j,k} = sequential_process(param);
        if(sequential{j,k}.feasible==0)%if infeasibility observed, then regenerate
            k = k-1;
            n_bad_instances = n_bad_instances + 1;
            continue;
        end
        %only run if forecasts are provided in sequential{j}
        %naive = naive_process(sequential{j,k}.forecasted,param.C);

        %%Simultaneous Process
        param.C2 = param.C0*sequential{j,k}.regularized_coeff;%the best one chosen from sequential
        am_data{j,k} = simultaneous_exhausive(param,'AM');% Alternating Minimization (default)
        %%nm_data{j,k} = simultaneous_exhausive(param,'NM');% NM+MILP if needed

        param_sample_size{j,k} = param;
        fprintf('MLOC multirun: j:%2d, k:%2d finished.\n',j,k);
    end
    save([result_path 'run_' ...
        datestr(now,'yyyy_mm_dd_HH') '00hrs_cost_type_' ...
        num2str(param0.cost_model_type) '.mat']);
end