% This function computes e value of the objective function for the simultaneous process.
function val = simultaneous_objective_function(...
                                lambda_model,...
                                route,...
                                param)
%latencies given a route (route gives the list if nodes without the starting node which is always node 1)
latencies = zeros(1,size(param.unLabeled,1)); %latencies is a row vector
route = [1 route];%assmes route is a row vector, added node 1 to the beginning, now length(route) == size(unLabeled,1) + 1
for i=2:length(route)-1%for every node pi(2) to last node before returning to node 1
    for j=1:i-1
        latencies(route(i)) = latencies(route(i)) + ...
                              param.C(...
                                route(j),...
                                route(j+1));%j+1 should be <= size(unLabeled,1)
    end
end
latencies(1) = latencies(route(length(route)-1)) + ...
                              param.C(...
                                route(length(route)-1),...
                                1);%distance from last node to node 1
    
%route cost as a function of route and lambda_model
route_cost = @(lambda_model) latencies*get_predicted_probabilities(param.unLabeled, ...
                                            param.n_features, ...
                                            lambda_model, ...
                                            param.cost_model_type)';%assmes q is a row vector and transposing it
                            
%compute the objective value for the given route and linear model
val = param.C0*sum(log(1+(exp(-(param.X_trn*lambda_model).*param.Y_trn))))/length(param.Y_trn) ...
        + param.C1*route_cost(lambda_model) ...
        + param.C2*norm(lambda_model)^2;
fprintf('MLOC total objective value: %5.3f\n',val);